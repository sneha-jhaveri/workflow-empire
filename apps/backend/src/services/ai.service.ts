import { z } from "zod";
import { Graph, createGraph } from "@core/workflow";

// Define the schema for AI-generated graphs
const GraphSpec = z.object({
  start: z.string(),
  nodes: z.record(
    z.object({
      id: z.string(),
      type: z.string(),
      params: z.record(z.any()).default({}),
      inputs: z.record(z.any()).default({}),
      label: z.string(),
    })
  ),
  edges: z.array(
    z.object({
      id: z.string(),
      source: z.string(),
      target: z.string(),
      to: z.string(),
      condition: z
        .function()
        .args(z.object({ ctx: z.any(), input: z.any() }))
        .returns(z.promise(z.boolean()))
        .optional(),
    })
  ),
});

type GraphSpecType = z.infer<typeof GraphSpec>;

// AI Service
export class AIService {
  static async generateGraph(prompt: string): Promise<Graph> {
    // Simulate AI generation logic
    const generatedGraph = {
      start: "node1",
      nodes: {
        node1: {
          id: "node1",
          type: "start",
          params: {},
          inputs: {},
          label: "Start Node",
        },
        node2: {
          id: "node2",
          type: "end",
          params: {},
          inputs: {},
          label: "End Node",
        },
      },
      edges: [
        {
          id: "edge1",
          source: "node1",
          target: "node2",
          to: "node2",
          condition: async () => true,
        },
      ],
    };

    // Validate the generated graph
    const parsed = GraphSpec.safeParse(generatedGraph);
    if (!parsed.success) {
      throw new Error("Invalid graph generated by AI");
    }

    return createGraph(parsed.data);
  }

  static async modifyGraph(graph: Graph, instruction: string): Promise<Graph> {
    // Simulate modification logic
    // Example: Add a new node based on the instruction
    const modifiedGraph = {
      ...graph,
      nodes: {
        ...graph.nodes,
        node3: {
          id: "node3",
          type: "newNode",
          params: {},
          inputs: {},
          label: "New Node",
        },
      },
      edges: [
        ...graph.edges,
        {
          id: "edge2",
          source: "node2",
          target: "node3",
          to: "node3",
          condition: async () => true,
        },
      ],
    };

    // Validate the modified graph
    const parsed = GraphSpec.safeParse(modifiedGraph);
    if (!parsed.success) {
      throw new Error("Invalid graph modification");
    }

    return createGraph(parsed.data);
  }

  static async explainNode(nodeId: string, graph: Graph): Promise<string> {
    // Simulate explanation logic
    const node = graph.nodes[nodeId];
    if (!node) {
      throw new Error(`Node with ID ${nodeId} not found`);
    }

    return `Node ${nodeId} is of type ${node.type} and performs a specific task.`;
  }
}
